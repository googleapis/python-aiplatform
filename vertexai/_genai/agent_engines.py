# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import logging
import time
from typing import Any, Iterator, Optional, Union
from urllib.parse import urlencode

from google.genai import _api_module
from google.genai import _common
from google.genai import types as genai_types
from google.genai._api_client import BaseApiClient
from google.genai._common import get_value_by_path as getv
from google.genai._common import set_value_by_path as setv
from google.genai.pagers import Pager

from . import types

logger = logging.getLogger("vertexai_genai.agentengines")


def _ReasoningEngineSpec_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["agent_framework"]) is not None:
        setv(
            to_object,
            ["agentFramework"],
            getv(from_object, ["agent_framework"]),
        )

    if getv(from_object, ["class_methods"]) is not None:
        setv(to_object, ["classMethods"], getv(from_object, ["class_methods"]))

    if getv(from_object, ["deployment_spec"]) is not None:
        setv(
            to_object,
            ["deploymentSpec"],
            getv(from_object, ["deployment_spec"]),
        )

    if getv(from_object, ["package_spec"]) is not None:
        setv(to_object, ["packageSpec"], getv(from_object, ["package_spec"]))

    return to_object


def _CreateAgentEngineConfig_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["display_name"]) is not None:
        setv(parent_object, ["displayName"], getv(from_object, ["display_name"]))

    if getv(from_object, ["description"]) is not None:
        setv(parent_object, ["description"], getv(from_object, ["description"]))

    if getv(from_object, ["spec"]) is not None:
        setv(
            parent_object,
            ["spec"],
            _ReasoningEngineSpec_to_vertex(
                api_client, getv(from_object, ["spec"]), to_object
            ),
        )

    return to_object


def _CreateAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _CreateAgentEngineConfig_to_vertex(
                api_client, getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _GetOperationParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["operation_name"]) is not None:
        setv(
            to_object,
            ["_url", "operationName"],
            getv(from_object, ["operation_name"]),
        )

    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    return to_object


def _DeleteAgentEngineConfig_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["force"]) is not None:
        setv(to_object, ["force"], getv(from_object, ["force"]))

    return to_object


def _DeleteAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _DeleteAgentEngineConfig_to_vertex(
                api_client, getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _GetAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    return to_object


def _ListAgentEngineConfig_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["page_size"]) is not None:
        setv(
            parent_object,
            ["_query", "pageSize"],
            getv(from_object, ["page_size"]),
        )

    if getv(from_object, ["page_token"]) is not None:
        setv(
            parent_object,
            ["_query", "pageToken"],
            getv(from_object, ["page_token"]),
        )

    if getv(from_object, ["filter"]) is not None:
        setv(parent_object, ["_query", "filter"], getv(from_object, ["filter"]))

    return to_object


def _ListAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _ListAgentEngineConfig_to_vertex(
                api_client, getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _QueryAgentEngineConfig_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["class_method"]) is not None:
        setv(parent_object, ["classMethod"], getv(from_object, ["class_method"]))

    if getv(from_object, ["input"]) is not None:
        setv(parent_object, ["input"], getv(from_object, ["input"]))

    if getv(from_object, ["include_all_fields"]) is not None:
        setv(
            to_object,
            ["includeAllFields"],
            getv(from_object, ["include_all_fields"]),
        )

    return to_object


def _QueryAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _QueryAgentEngineConfig_to_vertex(
                api_client, getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _UpdateAgentEngineConfig_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["display_name"]) is not None:
        setv(parent_object, ["displayName"], getv(from_object, ["display_name"]))

    if getv(from_object, ["description"]) is not None:
        setv(parent_object, ["description"], getv(from_object, ["description"]))

    if getv(from_object, ["spec"]) is not None:
        setv(
            parent_object,
            ["spec"],
            _ReasoningEngineSpec_to_vertex(
                api_client, getv(from_object, ["spec"]), to_object
            ),
        )

    return to_object


def _UpdateAgentEngineRequestParameters_to_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _UpdateAgentEngineConfig_to_vertex(
                api_client, getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _ReasoningEngine_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["createTime"]) is not None:
        setv(to_object, ["create_time"], getv(from_object, ["createTime"]))

    if getv(from_object, ["description"]) is not None:
        setv(to_object, ["description"], getv(from_object, ["description"]))

    if getv(from_object, ["displayName"]) is not None:
        setv(to_object, ["display_name"], getv(from_object, ["displayName"]))

    if getv(from_object, ["etag"]) is not None:
        setv(to_object, ["etag"], getv(from_object, ["etag"]))

    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["name"], getv(from_object, ["name"]))

    if getv(from_object, ["spec"]) is not None:
        setv(to_object, ["spec"], getv(from_object, ["spec"]))

    if getv(from_object, ["updateTime"]) is not None:
        setv(to_object, ["update_time"], getv(from_object, ["updateTime"]))

    return to_object


def _CreateAgentEngineOperation_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["name"], getv(from_object, ["name"]))

    if getv(from_object, ["metadata"]) is not None:
        setv(to_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["done"]) is not None:
        setv(to_object, ["done"], getv(from_object, ["done"]))

    if getv(from_object, ["error"]) is not None:
        setv(to_object, ["error"], getv(from_object, ["error"]))

    if getv(from_object, ["response"]) is not None:
        setv(
            to_object,
            ["response"],
            _ReasoningEngine_from_vertex(
                api_client, getv(from_object, ["response"]), to_object
            ),
        )

    return to_object


def _DeleteAgentEngineOperation_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["name"], getv(from_object, ["name"]))

    if getv(from_object, ["metadata"]) is not None:
        setv(to_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["done"]) is not None:
        setv(to_object, ["done"], getv(from_object, ["done"]))

    if getv(from_object, ["error"]) is not None:
        setv(to_object, ["error"], getv(from_object, ["error"]))

    return to_object


def _ListReasoningEnginesResponse_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["nextPageToken"]) is not None:
        setv(to_object, ["next_page_token"], getv(from_object, ["nextPageToken"]))

    if getv(from_object, ["reasoningEngines"]) is not None:
        setv(
            to_object,
            ["reasoning_engines"],
            [
                _ReasoningEngine_from_vertex(api_client, item, to_object)
                for item in getv(from_object, ["reasoningEngines"])
            ],
        )

    return to_object


def _QueryReasoningEngineResponse_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["output"]) is not None:
        setv(to_object, ["output"], getv(from_object, ["output"]))

    return to_object


def _UpdateAgentEngineOperation_from_vertex(
    api_client: BaseApiClient,
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["name"], getv(from_object, ["name"]))

    if getv(from_object, ["metadata"]) is not None:
        setv(to_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["done"]) is not None:
        setv(to_object, ["done"], getv(from_object, ["done"]))

    if getv(from_object, ["error"]) is not None:
        setv(to_object, ["error"], getv(from_object, ["error"]))

    return to_object


class AgentEngines(_api_module.BaseModule):
    def _create(
        self, *, config: Optional[types.CreateAgentEngineConfigOrDict] = None
    ) -> types.CreateAgentEngineOperation:
        """Creates a new Agent Engine."""

        parameter_model = types._CreateAgentEngineRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "reasoningEngines".format_map(request_url_dict)
            else:
                path = "reasoningEngines"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "post", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _CreateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.CreateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _get_create_operation(
        self,
        *,
        operation_name: str,
        config: Optional[types.GetOperationConfigOrDict] = None,
    ) -> types.CreateAgentEngineOperation:
        parameter_model = types._GetOperationParameters(
            operation_name=operation_name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetOperationParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{operationName}".format_map(request_url_dict)
            else:
                path = "{operationName}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _CreateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.CreateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def delete(
        self,
        *,
        name: str,
        config: Optional[types.DeleteAgentEngineConfigOrDict] = None,
    ) -> types.DeleteAgentEngineOperation:
        """Deletes an Agent Engine."""

        parameter_model = types._DeleteAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _DeleteAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "delete", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _DeleteAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.DeleteAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _get(
        self,
        *,
        name: str,
        config: Optional[types.GetAgentEngineConfigOrDict] = None,
    ) -> types.ReasoningEngine:
        """Get an Agent Engine instance."""

        parameter_model = types._GetAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _ReasoningEngine_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.ReasoningEngine._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _list(
        self, *, config: Optional[types.ListAgentEngineConfigOrDict] = None
    ) -> types.ListReasoningEnginesResponse:
        """Lists Agent Engines."""

        parameter_model = types._ListAgentEngineRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "reasoningEngines".format_map(request_url_dict)
            else:
                path = "reasoningEngines"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _ListReasoningEnginesResponse_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.ListReasoningEnginesResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _query(
        self,
        *,
        name: str,
        config: Optional[types.QueryAgentEngineConfigOrDict] = None,
    ) -> types.QueryReasoningEngineResponse:
        """Lists Agent Engines."""

        parameter_model = types._QueryAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _QueryAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}:query".format_map(request_url_dict)
            else:
                path = "{name}:query"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "post", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _QueryReasoningEngineResponse_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.QueryReasoningEngineResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _update(
        self,
        *,
        name: str,
        config: Optional[types.UpdateAgentEngineConfigOrDict] = None,
    ) -> types.UpdateAgentEngineOperation:
        """Updates an Agent Engine."""

        parameter_model = types._UpdateAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _UpdateAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = self._api_client.request(
            "patch", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _UpdateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.UpdateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    def _list_pager(
        self, *, config: Optional[types.ListAgentEngineConfigOrDict] = None
    ) -> Pager[types.ReasoningEngine]:
        return Pager(
            "reasoning_engines",
            self._list,
            self._list(config=config),
            config,
        )

    def get(
        self,
        *,
        name: str,
        config: Optional[types.GetAgentEngineConfigOrDict] = None,
    ) -> types.AgentEngine:
        """Gets an agent engine.

        Args:
            name (str): Required. A fully-qualified resource name or ID such as
              "projects/123/locations/us-central1/reasoningEngines/456" or a
              shortened name such as "reasoningEngines/456".
        """
        from vertexai.agent_engines import _agent_engines

        agent = types.AgentEngine(
            api_client=self,
            api_resource=self._get(name=name, config=config),
        )
        try:
            _agent_engines._register_api_methods_or_raise(agent)
        except Exception as e:
            logger.warning(
                _agent_engines._FAILED_TO_REGISTER_API_METHODS_WARNING_TEMPLATE,
                e,
            )
        return agent

    def create(
        self,
        agent_engine: Any = None,
        *,
        staging_bucket: str,
        requirements: Optional[Union[str, list[str]]] = None,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        gcs_dir_name: Optional[str] = None,
        extra_packages: Optional[list[str]] = None,
        env_vars: Optional[Union[list[str], dict[str, Union[str, Any]]]] = None,
        return_response: bool = True,
    ) -> Union[types.AgentEngine, types.CreateAgentEngineOperation]:
        """Creates an agent engine.

        The Agent Engine will be an instance of the `agent_engine` that
        was passed in, running remotely on Vertex AI.

        Sample ``src_dir`` contents (e.g. ``./user_src_dir``):

        .. code-block:: python

            user_src_dir/
            |-- main.py
            |-- requirements.txt
            |-- user_code/
            |   |-- utils.py
            |   |-- ...
            |-- ...

        To build an Agent Engine with the above files, run:

        .. code-block:: python

            client = vertexai.genai.client.Client(
                project="your-project",
                location="us-central1",
            )
            remote_agent = client.agent_engines.create(
                agent_engine=local_agent,
                requirements=[
                    # I.e. the PyPI dependencies listed in requirements.txt
                    "google-cloud-aiplatform[agent_engines,adk]",
                    ...
                ],
                extra_packages=[
                    "./user_src_dir/main.py", # a single file
                    "./user_src_dir/user_code", # a directory
                    ...
                ],
            )

        Args:
            staging_bucket (str): Required. The GCS bucket to use for staging
              the artifacts needed. It must be a valid GCS bucket name, e.g.
              "gs://bucket-name".
            agent_engine (Any): Optional. The Agent Engine to be created. If not
              specified, this will correspond to a lightweight instance that
              cannot be queried (but can be updated to future instances that can
              be queried).
            requirements (Union[str, Sequence[str]]): Optional. The set of PyPI
              dependencies needed. It can either be the path to a single file
              (requirements.txt), or an ordered list of strings corresponding to
              each line of the requirements file.
            display_name (str): Optional. The user-defined name of the Agent
              Engine. The name can be up to 128 characters long and can comprise
              any UTF-8 character.
            description (str): Optional. The description of the Agent Engine.
            gcs_dir_name (str): Optional. The GCS bucket directory under
              `staging_bucket` to use for staging the artifacts needed.
            extra_packages (Sequence[str]): Optional. The set of extra
              user-provided packages (if any).
            env_vars (Union[Sequence[str], Dict[str, Union[str, SecretRef]]]):
              Optional. The environment variables to be set when running the
              Agent Engine. If it is a list of strings, each string should be a
              valid key to `os.environ`. If it is a dictionary, the keys are the
              environment variable names, and the values are the corresponding
              values.
            return_response (bool): Optional. If True, the response will be
              returned. Otherwise, the operation will be returned.

        Returns:
            Union[types.AgentEngine, types.CreateAgentEngineOperation]:
                It returns the Agent Engine if `return_response` is True,
                otherwise
                it returns the operation for creating the Agent Engine.

        Raises:
            ValueError: If the `project` was not set using `client.Client`.
            ValueError: If the `location` was not set using `client.Client`.
            ValueError: If the `staging_bucket` was not set.
            ValueError: If the `staging_bucket` does not start with "gs://".
            ValueError: If `extra_packages` is specified but `agent_engine` is
            None.
            ValueError: If `requirements` is specified but `agent_engine` is
            None.
            ValueError: If `env_vars` has a dictionary entry that does not
            correspond to a SecretRef.
            ValueError: If `env_vars` is a list which contains a string that
            does not exist in `os.environ`.
            TypeError: If `env_vars` is not a list of strings or a dictionary.
            TypeError: If `env_vars` has a value that is not a string or
            SecretRef.
            FileNotFoundError: If `extra_packages` includes a file or directory
            that does not exist.
            IOError: If requirements is a string that corresponds to a
            nonexistent file.
        """
        config = self._create_config(
            agent_engine=agent_engine,
            staging_bucket=staging_bucket,
            requirements=requirements,
            display_name=display_name,
            description=description,
            gcs_dir_name=gcs_dir_name,
            extra_packages=extra_packages,
            env_vars=env_vars,
        )
        operation = self._create(config=config)
        if return_response:
            return self._await_create_operation(operation_name=operation.name)
        return operation

    def _create_config(
        self,
        *,
        agent_engine: Any = None,
        staging_bucket: str,
        requirements: Optional[Union[str, list[str]]] = None,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        gcs_dir_name: Optional[str] = None,
        extra_packages: Optional[list[str]] = None,
        env_vars: Optional[Union[list[str], dict[str, Union[str, Any]]]] = None,
    ):
        import sys
        from vertexai.agent_engines import _agent_engines
        from vertexai.agent_engines import _utils

        sys_version = f"{sys.version_info.major}.{sys.version_info.minor}"
        gcs_dir_name = gcs_dir_name or _agent_engines._DEFAULT_GCS_DIR_NAME
        if agent_engine is not None:
            agent_engine = _agent_engines._validate_agent_engine_or_raise(agent_engine)
            _agent_engines._validate_staging_bucket_or_raise(staging_bucket)
        if agent_engine is None:
            if requirements is not None:
                raise ValueError("requirements must be None if agent_engine is None.")
            if extra_packages is not None:
                raise ValueError("extra_packages must be None if agent_engine is None.")
        requirements = _agent_engines._validate_requirements_or_raise(
            agent_engine=agent_engine,
            requirements=requirements,
        )
        extra_packages = _agent_engines._validate_extra_packages_or_raise(
            extra_packages
        )
        # Prepares the Agent Engine for creation in Vertex AI. This involves
        # packaging and uploading the artifacts for agent_engine, requirements and
        # extra_packages to `staging_bucket/gcs_dir_name`.
        _agent_engines._prepare(
            agent_engine=agent_engine,
            requirements=requirements,
            project=self._api_client.project,
            location=self._api_client.location,
            staging_bucket=staging_bucket,
            gcs_dir_name=gcs_dir_name,
            extra_packages=extra_packages,
        )
        config = {"display_name": display_name, "description": description}
        if agent_engine is not None:
            # Update the package spec.
            package_spec = {
                "python_version": sys_version,
                "pickle_object_gcs_uri": "{}/{}/{}".format(
                    staging_bucket,
                    gcs_dir_name,
                    _agent_engines._BLOB_FILENAME,
                ),
            }
            if extra_packages:
                package_spec["dependency_files_gcs_uri"] = "{}/{}/{}".format(
                    staging_bucket,
                    gcs_dir_name,
                    _agent_engines._EXTRA_PACKAGES_FILE,
                )
            if requirements:
                package_spec["requirements_gcs_uri"] = "{}/{}/{}".format(
                    staging_bucket,
                    gcs_dir_name,
                    _agent_engines._REQUIREMENTS_FILE,
                )
            agent_engine_spec = {"package_spec": package_spec}
            if env_vars:
                deployment_spec, _ = _agent_engines._generate_deployment_spec_or_raise(
                    env_vars=env_vars
                )
                agent_engine_spec["deployment_spec"] = deployment_spec
            class_methods = _agent_engines._generate_class_methods_spec_or_raise(
                agent_engine=agent_engine,
                operations=_agent_engines._get_registered_operations(agent_engine),
            )
            agent_engine_spec["class_methods"] = [
                _utils.to_dict(class_method) for class_method in class_methods
            ]
            agent_engine_spec["agent_framework"] = _agent_engines._get_agent_framework(
                agent_engine
            )
            config["spec"] = agent_engine_spec
        return config

    def _await_create_operation(
        self,
        *,
        operation_name: str,
        poll_interval_seconds: int = 10,
    ) -> types.AgentEngine:
        """Waits for the operation for creating an agent engine to complete.

        Args:
            operation_name (str): Required. The name of the operation for
              creating the Agent Engine.
            poll_interval_seconds (int): The number of seconds to wait between
              each poll.

        Returns:
            AgentEngine: The Agent Engine that was created.
        """
        from vertexai.agent_engines import _agent_engines

        operation = self._get_create_operation(operation_name=operation_name)
        while not operation.done:
            time.sleep(poll_interval_seconds)
            operation = self._get_create_operation(operation_name=operation.name)

        agent = types.AgentEngine(api_client=self, api_resource=operation.response)

        try:
            _agent_engines._register_api_methods_or_raise(agent)
        except Exception as e:
            logger.warning(
                _agent_engines._FAILED_TO_REGISTER_API_METHODS_WARNING_TEMPLATE,
                e,
            )
        return agent

    def list(
        self, *, config: Optional[types.ListAgentEngineConfigOrDict] = None
    ) -> Iterator[types.AgentEngine]:
        """Lists agent engines that matches the configuration."""

        for reasoning_engine in self._list_pager(config=config):
            yield types.AgentEngine(
                api_client=self,
                api_resource=reasoning_engine,
            )

    def _stream_query(
        self,
        *,
        name: str,
        config: Optional[types.QueryAgentEngineConfigOrDict] = None,
    ) -> Iterator[Any]:
        """Streams the response of the agent engine."""
        parameter_model = types._QueryAgentEngineRequestParameters(
            name=name,
            config=config,
        )
        request_dict = _QueryAgentEngineRequestParameters_to_vertex(
            self._api_client, parameter_model
        )
        request_url_dict = request_dict.get("_url")
        if request_url_dict:
            path = "{name}:streamQuery?alt=sse".format_map(request_url_dict)
        else:
            path = "{name}:streamQuery?alt=sse"
        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)
        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)
        for response in self._api_client.request_streamed(
            "post", path, request_dict, http_options
        ):
            yield response


class AsyncAgentEngines(_api_module.BaseModule):
    async def _create(
        self, *, config: Optional[types.CreateAgentEngineConfigOrDict] = None
    ) -> types.CreateAgentEngineOperation:
        """Creates a new Agent Engine."""

        parameter_model = types._CreateAgentEngineRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "reasoningEngines".format_map(request_url_dict)
            else:
                path = "reasoningEngines"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "post", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _CreateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.CreateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def _get_create_operation(
        self,
        *,
        operation_name: str,
        config: Optional[types.GetOperationConfigOrDict] = None,
    ) -> types.CreateAgentEngineOperation:
        parameter_model = types._GetOperationParameters(
            operation_name=operation_name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetOperationParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{operationName}".format_map(request_url_dict)
            else:
                path = "{operationName}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _CreateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.CreateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def delete(
        self,
        *,
        name: str,
        config: Optional[types.DeleteAgentEngineConfigOrDict] = None,
    ) -> types.DeleteAgentEngineOperation:
        """Deletes an Agent Engine."""

        parameter_model = types._DeleteAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _DeleteAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "delete", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _DeleteAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.DeleteAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def _get(
        self,
        *,
        name: str,
        config: Optional[types.GetAgentEngineConfigOrDict] = None,
    ) -> types.ReasoningEngine:
        """Get an Agent Engine instance."""

        parameter_model = types._GetAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _ReasoningEngine_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.ReasoningEngine._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def _list(
        self, *, config: Optional[types.ListAgentEngineConfigOrDict] = None
    ) -> types.ListReasoningEnginesResponse:
        """Lists Agent Engines."""

        parameter_model = types._ListAgentEngineRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "reasoningEngines".format_map(request_url_dict)
            else:
                path = "reasoningEngines"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _ListReasoningEnginesResponse_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.ListReasoningEnginesResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def _query(
        self,
        *,
        name: str,
        config: Optional[types.QueryAgentEngineConfigOrDict] = None,
    ) -> types.QueryReasoningEngineResponse:
        """Lists Agent Engines."""

        parameter_model = types._QueryAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _QueryAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}:query".format_map(request_url_dict)
            else:
                path = "{name}:query"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "post", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _QueryReasoningEngineResponse_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.QueryReasoningEngineResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value

    async def _update(
        self,
        *,
        name: str,
        config: Optional[types.UpdateAgentEngineConfigOrDict] = None,
    ) -> types.UpdateAgentEngineOperation:
        """Updates an Agent Engine."""

        parameter_model = types._UpdateAgentEngineRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _UpdateAgentEngineRequestParameters_to_vertex(
                self._api_client, parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[genai_types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response_dict = await self._api_client.async_request(
            "patch", path, request_dict, http_options
        )

        if self._api_client.vertexai:
            response_dict = _UpdateAgentEngineOperation_from_vertex(
                self._api_client, response_dict
            )

        return_value = types.UpdateAgentEngineOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )
        self._api_client._verify_response(return_value)
        return return_value
