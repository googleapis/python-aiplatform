# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import functools
import importlib
import json
import logging
import typing
from typing import Any, Iterator, Optional, Union
from urllib.parse import urlencode

from google.genai import _api_module
from google.genai import _common
from google.genai._common import get_value_by_path as getv
from google.genai._common import set_value_by_path as setv
from google.genai.pagers import Pager

from . import types

if typing.TYPE_CHECKING:
    from . import a2a_task_events as a2a_task_events_module

    _ = a2a_task_events_module


logger = logging.getLogger("vertexai_genai.a2atasks")

logger.setLevel(logging.INFO)


def _CreateAgentEngineTaskConfig_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["context_id"]) is not None:
        setv(parent_object, ["contextId"], getv(from_object, ["context_id"]))

    if getv(from_object, ["metadata"]) is not None:
        setv(parent_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["state"]) is not None:
        setv(parent_object, ["state"], getv(from_object, ["state"]))

    if getv(from_object, ["status_details"]) is not None:
        setv(parent_object, ["statusDetails"], getv(from_object, ["status_details"]))

    if getv(from_object, ["output"]) is not None:
        setv(parent_object, ["output"], getv(from_object, ["output"]))

    return to_object


def _CreateAgentEngineTaskRequestParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["a2a_task_id"]) is not None:
        setv(to_object, ["_query", "a2a_task_id"], getv(from_object, ["a2a_task_id"]))

    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _CreateAgentEngineTaskConfig_to_vertex(
                getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _GetAgentEngineTaskRequestParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    return to_object


def _ListAgentEngineTasksConfig_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["page_size"]) is not None:
        setv(parent_object, ["_query", "pageSize"], getv(from_object, ["page_size"]))

    if getv(from_object, ["page_token"]) is not None:
        setv(parent_object, ["_query", "pageToken"], getv(from_object, ["page_token"]))

    if getv(from_object, ["filter"]) is not None:
        setv(parent_object, ["_query", "filter"], getv(from_object, ["filter"]))

    if getv(from_object, ["order_by"]) is not None:
        setv(parent_object, ["_query", "orderBy"], getv(from_object, ["order_by"]))

    return to_object


def _ListAgentEngineTasksRequestParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _ListAgentEngineTasksConfig_to_vertex(
                getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


class A2aTasks(_api_module.BaseModule):

    def get(
        self,
        *,
        name: str,
        config: Optional[types.GetAgentEngineTaskConfigOrDict] = None,
    ) -> types.A2aTask:
        """
        Gets an agent engine task.

        Args:
            name (str): Required. The name of the Agent Engine task to get. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}/a2aTasks/{task_id}`.
            config (GetAgentEngineTaskConfig):
                Optional. Additional configurations for getting the Agent Engine task.

        Returns:
            AgentEngineTask: The requested Agent Engine task.

        """

        parameter_model = types._GetAgentEngineTaskRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetAgentEngineTaskRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("get", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.A2aTask._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _list(
        self,
        *,
        name: str,
        config: Optional[types.ListAgentEngineTasksConfigOrDict] = None,
    ) -> types.ListAgentEngineTasksResponse:
        """
        Lists Agent Engine tasks.

        Args:
            name (str): Required. The name of the Agent Engine to list tasks for. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}`.
            config (ListAgentEngineTasksConfig):
                Optional. Additional configurations for listing the Agent Engine tasks.

        Returns:
            ListAgentEngineTasksResponse: The requested Agent Engine tasks.

        """

        parameter_model = types._ListAgentEngineTasksRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListAgentEngineTasksRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}/a2aTasks".format_map(request_url_dict)
            else:
                path = "{name}/a2aTasks"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("get", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.ListAgentEngineTasksResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def create(
        self,
        *,
        name: str,
        a2a_task_id: str,
        config: Optional[types.CreateAgentEngineTaskConfigOrDict] = None,
    ) -> types.A2aTask:
        """
        Creates a new task in the Agent Engine.

        Args:
            name (str): Required. The name of the Agent Engine to create the task under. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}`.
            a2a_task_id (str): Required. The user ID of the task.
            context_id (str): Required. The ID of the context to use for the task.
            config (CreateAgentEngineTaskConfig):
                Optional. Additional configurations for creating the Agent Engine task.

        Returns:
            A2aTask: The created Agent Engine task.

        """

        parameter_model = types._CreateAgentEngineTaskRequestParameters(
            name=name,
            a2a_task_id=a2a_task_id,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateAgentEngineTaskRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}/a2aTasks".format_map(request_url_dict)
            else:
                path = "{name}/a2aTasks"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("post", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.A2aTask._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    _events = None

    def list(
        self,
        *,
        name: str,
        config: Optional[types.ListAgentEngineTasksConfigOrDict] = None,
    ) -> Iterator[types.A2aTask]:
        """Lists the A2A tasks of an Agent Engine.

        Args:
            name (str):
                Required. The name of the agent engine to list tasks for.
            config (List):
                Optional. The configuration for the tasks to list.

        Returns:
            Iterable[A2aTask]: An iterable of A2A tasks.
        """

        return Pager(
            "a2aTasks",
            functools.partial(self._list, name=name),
            self._list(name=name, config=config),
            config,
        )

    @property
    def events(self) -> "a2a_task_events_module.A2aTaskEvents":
        if self._events is None:
            try:
                # We need to lazy load the events module to handle the
                # possibility of ImportError when dependencies are not installed.
                self._events = importlib.import_module(".a2a_task_events", __package__)
            except ImportError as e:
                raise ImportError(
                    "The 'agent_engines.a2a_tasks.events' module requires additional "
                    "packages. Please install them using pip install "
                    "google-cloud-aiplatform[agent_engines]"
                ) from e
        return self._events.A2aTaskEvents(self._api_client)  # type: ignore[no-any-return]


class AsyncA2aTasks(_api_module.BaseModule):

    async def get(
        self,
        *,
        name: str,
        config: Optional[types.GetAgentEngineTaskConfigOrDict] = None,
    ) -> types.A2aTask:
        """
        Gets an agent engine task.

        Args:
            name (str): Required. The name of the Agent Engine task to get. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}/a2aTasks/{task_id}`.
            config (GetAgentEngineTaskConfig):
                Optional. Additional configurations for getting the Agent Engine task.

        Returns:
            AgentEngineTask: The requested Agent Engine task.

        """

        parameter_model = types._GetAgentEngineTaskRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetAgentEngineTaskRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}".format_map(request_url_dict)
            else:
                path = "{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.A2aTask._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _list(
        self,
        *,
        name: str,
        config: Optional[types.ListAgentEngineTasksConfigOrDict] = None,
    ) -> types.ListAgentEngineTasksResponse:
        """
        Lists Agent Engine tasks.

        Args:
            name (str): Required. The name of the Agent Engine to list tasks for. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}`.
            config (ListAgentEngineTasksConfig):
                Optional. Additional configurations for listing the Agent Engine tasks.

        Returns:
            ListAgentEngineTasksResponse: The requested Agent Engine tasks.

        """

        parameter_model = types._ListAgentEngineTasksRequestParameters(
            name=name,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListAgentEngineTasksRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}/a2aTasks".format_map(request_url_dict)
            else:
                path = "{name}/a2aTasks"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.ListAgentEngineTasksResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def create(
        self,
        *,
        name: str,
        a2a_task_id: str,
        config: Optional[types.CreateAgentEngineTaskConfigOrDict] = None,
    ) -> types.A2aTask:
        """
        Creates a new task in the Agent Engine.

        Args:
            name (str): Required. The name of the Agent Engine to create the task under. Format:
                `projects/{project}/locations/{location}/reasoningEngines/{resource_id}`.
            a2a_task_id (str): Required. The user ID of the task.
            context_id (str): Required. The ID of the context to use for the task.
            config (CreateAgentEngineTaskConfig):
                Optional. Additional configurations for creating the Agent Engine task.

        Returns:
            A2aTask: The created Agent Engine task.

        """

        parameter_model = types._CreateAgentEngineTaskRequestParameters(
            name=name,
            a2a_task_id=a2a_task_id,
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateAgentEngineTaskRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "{name}/a2aTasks".format_map(request_url_dict)
            else:
                path = "{name}/a2aTasks"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "post", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.A2aTask._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value
