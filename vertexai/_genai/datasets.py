# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import asyncio
import json
import logging
import time
from typing import Any, Optional, Union
from urllib.parse import urlencode

from google.genai import _api_module
from google.genai import _common
from google.genai import types as genai_types
from google.genai._common import get_value_by_path as getv
from google.genai._common import set_value_by_path as setv

from . import _datasets_utils
from . import types


logger = logging.getLogger("vertexai_genai.datasets")


def _CreateMultimodalDatasetParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["name"], getv(from_object, ["name"]))

    if getv(from_object, ["display_name"]) is not None:
        setv(to_object, ["displayName"], getv(from_object, ["display_name"]))

    if getv(from_object, ["metadata_schema_uri"]) is not None:
        setv(
            to_object, ["metadataSchemaUri"], getv(from_object, ["metadata_schema_uri"])
        )

    if getv(from_object, ["metadata"]) is not None:
        setv(to_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["description"]) is not None:
        setv(to_object, ["description"], getv(from_object, ["description"]))

    if getv(from_object, ["encryption_spec"]) is not None:
        setv(to_object, ["encryptionSpec"], getv(from_object, ["encryption_spec"]))

    return to_object


def _DeleteMultimodalDatasetRequestParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    return to_object


def _GetMultimodalDatasetOperationParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    if getv(from_object, ["dataset_id"]) is not None:
        setv(to_object, ["_url", "dataset_id"], getv(from_object, ["dataset_id"]))

    if getv(from_object, ["operation_id"]) is not None:
        setv(to_object, ["_url", "operation_id"], getv(from_object, ["operation_id"]))

    return to_object


def _GetMultimodalDatasetParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    return to_object


def _ListMultimodalDatasetsConfig_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}

    if getv(from_object, ["page_size"]) is not None:
        setv(parent_object, ["_query", "pageSize"], getv(from_object, ["page_size"]))

    if getv(from_object, ["page_token"]) is not None:
        setv(parent_object, ["_query", "pageToken"], getv(from_object, ["page_token"]))

    if getv(from_object, ["filter"]) is not None:
        setv(parent_object, ["_query", "filter"], getv(from_object, ["filter"]))

    return to_object


def _ListMultimodalDatasetsRequestParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(
            to_object,
            ["config"],
            _ListMultimodalDatasetsConfig_to_vertex(
                getv(from_object, ["config"]), to_object
            ),
        )

    return to_object


def _UpdateMultimodalDatasetParameters_to_vertex(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    to_object: dict[str, Any] = {}
    if getv(from_object, ["config"]) is not None:
        setv(to_object, ["config"], getv(from_object, ["config"]))

    if getv(from_object, ["name"]) is not None:
        setv(to_object, ["_url", "name"], getv(from_object, ["name"]))

    if getv(from_object, ["display_name"]) is not None:
        setv(to_object, ["displayName"], getv(from_object, ["display_name"]))

    if getv(from_object, ["metadata"]) is not None:
        setv(to_object, ["metadata"], getv(from_object, ["metadata"]))

    if getv(from_object, ["description"]) is not None:
        setv(to_object, ["description"], getv(from_object, ["description"]))

    if getv(from_object, ["encryption_spec"]) is not None:
        setv(to_object, ["encryptionSpec"], getv(from_object, ["encryption_spec"]))

    return to_object


class Datasets(_api_module.BaseModule):

    def _create_multimodal_dataset(
        self,
        *,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
        name: Optional[str] = None,
        display_name: Optional[str] = None,
        metadata_schema_uri: Optional[str] = None,
        metadata: Optional[types.SchemaTablesDatasetMetadataOrDict] = None,
        description: Optional[str] = None,
        encryption_spec: Optional[genai_types.EncryptionSpecOrDict] = None,
    ) -> types.MultimodalDatasetOperation:
        """
        Creates a dataset resource to store multimodal datasets.
        """

        parameter_model = types._CreateMultimodalDatasetParameters(
            config=config,
            name=name,
            display_name=display_name,
            metadata_schema_uri=metadata_schema_uri,
            metadata=metadata,
            description=description,
            encryption_spec=encryption_spec,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets".format_map(request_url_dict)
            else:
                path = "datasets"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("post", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _delete_multimodal_dataset(
        self, *, config: Optional[types.VertexBaseConfigOrDict] = None, name: str
    ) -> types.MultimodalDatasetOperation:
        """
        Deletes a multimodal dataset resource.
        """

        parameter_model = types._DeleteMultimodalDatasetRequestParameters(
            config=config,
            name=name,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _DeleteMultimodalDatasetRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("delete", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _get_multimodal_dataset(
        self,
        *,
        config: Optional[types.VertexBaseConfigOrDict] = None,
        name: Optional[str] = None,
    ) -> types.MultimodalDataset:
        """
        Gets a multimodal dataset resource.
        """

        parameter_model = types._GetMultimodalDatasetParameters(
            config=config,
            name=name,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("get", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDataset._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _get_multimodal_dataset_operation(
        self,
        *,
        config: Optional[types.GetMultimodalDatasetOperationConfigOrDict] = None,
        dataset_id: Optional[str] = None,
        operation_id: Optional[str] = None,
    ) -> types.MultimodalDatasetOperation:
        """
        Gets the operation from creating a multimodal dataset.
        """

        parameter_model = types._GetMultimodalDatasetOperationParameters(
            config=config,
            dataset_id=dataset_id,
            operation_id=operation_id,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetMultimodalDatasetOperationParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{dataset_id}/operations/{operation_id}".format_map(
                    request_url_dict
                )
            else:
                path = "datasets/{dataset_id}/operations/{operation_id}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("get", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _list_multimodal_datasets(
        self, *, config: Optional[types.ListMultimodalDatasetsConfigOrDict] = None
    ) -> types.ListMultimodalDatasetsResponse:
        """
        Lists multimodal datasets.
        """

        parameter_model = types._ListMultimodalDatasetsRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListMultimodalDatasetsRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets".format_map(request_url_dict)
            else:
                path = "datasets"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("get", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.ListMultimodalDatasetsResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _update_multimodal_dataset(
        self,
        *,
        config: Optional[types.UpdateMultimodalDatasetConfigOrDict] = None,
        name: Optional[str] = None,
        display_name: Optional[str] = None,
        metadata: Optional[types.SchemaTablesDatasetMetadataOrDict] = None,
        description: Optional[str] = None,
        encryption_spec: Optional[genai_types.EncryptionSpecOrDict] = None,
    ) -> types.MultimodalDataset:
        """
        Updates a multimodal dataset resource.
        """

        parameter_model = types._UpdateMultimodalDatasetParameters(
            config=config,
            name=name,
            display_name=display_name,
            metadata=metadata,
            description=description,
            encryption_spec=encryption_spec,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _UpdateMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = self._api_client.request("patch", path, request_dict, http_options)

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDataset._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    def _wait_for_operation(
        self,
        operation: types.MultimodalDatasetOperation,
        timeout_seconds: int,
    ) -> types.MultimodalDataset:
        """Waits for a multimodal dataset operation to complete.

        Args:
          operation: The multimodal dataset operation to wait for.
          timeout_seconds: The maximum time in seconds to wait for the operation
          to complete.

        Returns:
          The name of the Multimodal Dataset resource from the operation result.

        Raises:
          TimeoutError: If the operation does not complete within the timeout.
          ValueError: If the operation fails.
        """
        multimodal_operation: Optional[types.MultimodalDatasetOperation] = None

        response_operation_name = operation.name
        dataset_id = response_operation_name.split("/datasets/")[1].split("/")[0]
        operation_id = response_operation_name.split("/")[-1]

        start_time = time.time()
        sleep_duration_seconds = 5
        wait_multiplier = 2
        max_wait_time_seconds = 60

        while (time.time() - start_time) < timeout_seconds:
            multimodal_operation = self._get_multimodal_dataset_operation(
                dataset_id=dataset_id,
                operation_id=operation_id,
            )
            if multimodal_operation.done:
                break
            time.sleep(sleep_duration_seconds)
            sleep_duration_seconds = min(
                sleep_duration_seconds * wait_multiplier, max_wait_time_seconds
            )
        else:
            raise TimeoutError(
                "Create multimodal dataset operation did not complete within the"
                f" specified timeout of {timeout_seconds} seconds."
            )
        if (
            not multimodal_operation
            or multimodal_operation.response is None
            or multimodal_operation.response.name is None
        ):
            logger.error(
                f"Error creating multimodal dataset resource for the operation {operation.name}."
            )
            raise ValueError("Error creating multimodal dataset resource.")
        if (
            hasattr(multimodal_operation, "error")
            and multimodal_operation.error is not None
        ):
            raise ValueError(
                f"Error creating multimodal dataset resource: {multimodal_operation.error}"
            )
        return multimodal_operation.response

    def create_from_bigquery(
        self,
        *,
        multimodal_dataset: types.MultimodalDatasetOrDict,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Creates a multimodal dataset from a BigQuery table.

        Args:
          multimodal_dataset:
            Required. A representation of a multimodal dataset.
          config:
            Optional. A configuration for creating the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing a multimodal dataset.
        """
        if isinstance(multimodal_dataset, dict):
            multimodal_dataset = types.MultimodalDataset(**multimodal_dataset)
        if not multimodal_dataset.metadata.input_config.bigquery_source.uri.startswith(
            "bq://"
        ):
            multimodal_dataset.metadata.input_config.bigquery_source.uri = (
                f"bq://{multimodal_dataset.metadata.input_config.bigquery_source.uri}"
            )
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        multimodal_dataset_operation = self._create_multimodal_dataset(
            config=config,
            display_name=multimodal_dataset.display_name,
            metadata_schema_uri=_datasets_utils.METADATA_SCHEMA_URI,
            metadata=multimodal_dataset.metadata,
        )
        return self._wait_for_operation(
            operation=multimodal_dataset_operation,
            timeout_seconds=config.timeout,
        )

    def update_multimodal_dataset(
        self,
        *,
        multimodal_dataset: types.MultimodalDatasetOrDict,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Updates a multimodal dataset.

        Updatable fields include:
        - display_name
        - description

        Args:
          multimodal_dataset:
            Required. A representation of a multimodal dataset.
          config:
            Optional. A configuration for updating the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing the retrieved multimodal
          dataset.
        """
        if isinstance(multimodal_dataset, dict):
            multimodal_dataset = types.MultimodalDataset(**multimodal_dataset)
        if not multimodal_dataset.metadata.input_config.bigquery_source.uri.startswith(
            "bq://"
        ):
            multimodal_dataset.metadata.input_config.bigquery_source.uri = (
                f"bq://{multimodal_dataset.metadata.input_config.bigquery_source.uri}"
            )
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return self._update_multimodal_dataset(
            config=config,
            name=multimodal_dataset.name,
            display_name=multimodal_dataset.display_name,
            description=multimodal_dataset.description,
            metadata=multimodal_dataset.metadata,
        )

    def get_multimodal_dataset(
        self,
        *,
        name: str,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Gets a multimodal dataset.

        Args:
          name:
            Required. name of a multimodal dataset.
          config:
            Optional. A configuration for getting the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing the retrieved multimodal
          dataset.
        """
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return self._get_multimodal_dataset(config=config, name=name)

    def delete_multimodal_dataset(
        self,
        *,
        name: str,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDatasetOperation:
        """Deletes a multimodal dataset.

        Args:
          name:
            Required. name of a multimodal dataset.
          config:
            Optional. A configuration for deleting the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDatasetOperation object representing the delete
          multimodal dataset operation.
        """
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return self._delete_multimodal_dataset(config=config, name=name)


class AsyncDatasets(_api_module.BaseModule):

    async def _create_multimodal_dataset(
        self,
        *,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
        name: Optional[str] = None,
        display_name: Optional[str] = None,
        metadata_schema_uri: Optional[str] = None,
        metadata: Optional[types.SchemaTablesDatasetMetadataOrDict] = None,
        description: Optional[str] = None,
        encryption_spec: Optional[genai_types.EncryptionSpecOrDict] = None,
    ) -> types.MultimodalDatasetOperation:
        """
        Creates a dataset resource to store multimodal datasets.
        """

        parameter_model = types._CreateMultimodalDatasetParameters(
            config=config,
            name=name,
            display_name=display_name,
            metadata_schema_uri=metadata_schema_uri,
            metadata=metadata,
            description=description,
            encryption_spec=encryption_spec,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _CreateMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets".format_map(request_url_dict)
            else:
                path = "datasets"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "post", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _delete_multimodal_dataset(
        self, *, config: Optional[types.VertexBaseConfigOrDict] = None, name: str
    ) -> types.MultimodalDatasetOperation:
        """
        Deletes a multimodal dataset resource.
        """

        parameter_model = types._DeleteMultimodalDatasetRequestParameters(
            config=config,
            name=name,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _DeleteMultimodalDatasetRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "delete", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _get_multimodal_dataset(
        self,
        *,
        config: Optional[types.VertexBaseConfigOrDict] = None,
        name: Optional[str] = None,
    ) -> types.MultimodalDataset:
        """
        Gets a multimodal dataset resource.
        """

        parameter_model = types._GetMultimodalDatasetParameters(
            config=config,
            name=name,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDataset._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _get_multimodal_dataset_operation(
        self,
        *,
        config: Optional[types.GetMultimodalDatasetOperationConfigOrDict] = None,
        dataset_id: Optional[str] = None,
        operation_id: Optional[str] = None,
    ) -> types.MultimodalDatasetOperation:
        """
        Gets the operation from creating a multimodal dataset.
        """

        parameter_model = types._GetMultimodalDatasetOperationParameters(
            config=config,
            dataset_id=dataset_id,
            operation_id=operation_id,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _GetMultimodalDatasetOperationParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{dataset_id}/operations/{operation_id}".format_map(
                    request_url_dict
                )
            else:
                path = "datasets/{dataset_id}/operations/{operation_id}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDatasetOperation._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _list_multimodal_datasets(
        self, *, config: Optional[types.ListMultimodalDatasetsConfigOrDict] = None
    ) -> types.ListMultimodalDatasetsResponse:
        """
        Lists multimodal datasets.
        """

        parameter_model = types._ListMultimodalDatasetsRequestParameters(
            config=config,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _ListMultimodalDatasetsRequestParameters_to_vertex(
                parameter_model
            )
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets".format_map(request_url_dict)
            else:
                path = "datasets"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "get", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.ListMultimodalDatasetsResponse._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _update_multimodal_dataset(
        self,
        *,
        config: Optional[types.UpdateMultimodalDatasetConfigOrDict] = None,
        name: Optional[str] = None,
        display_name: Optional[str] = None,
        metadata: Optional[types.SchemaTablesDatasetMetadataOrDict] = None,
        description: Optional[str] = None,
        encryption_spec: Optional[genai_types.EncryptionSpecOrDict] = None,
    ) -> types.MultimodalDataset:
        """
        Updates a multimodal dataset resource.
        """

        parameter_model = types._UpdateMultimodalDatasetParameters(
            config=config,
            name=name,
            display_name=display_name,
            metadata=metadata,
            description=description,
            encryption_spec=encryption_spec,
        )

        request_url_dict: Optional[dict[str, str]]
        if not self._api_client.vertexai:
            raise ValueError("This method is only supported in the Vertex AI client.")
        else:
            request_dict = _UpdateMultimodalDatasetParameters_to_vertex(parameter_model)
            request_url_dict = request_dict.get("_url")
            if request_url_dict:
                path = "datasets/{name}".format_map(request_url_dict)
            else:
                path = "datasets/{name}"

        query_params = request_dict.get("_query")
        if query_params:
            path = f"{path}?{urlencode(query_params)}"
        # TODO: remove the hack that pops config.
        request_dict.pop("config", None)

        http_options: Optional[types.HttpOptions] = None
        if (
            parameter_model.config is not None
            and parameter_model.config.http_options is not None
        ):
            http_options = parameter_model.config.http_options

        request_dict = _common.convert_to_dict(request_dict)
        request_dict = _common.encode_unserializable_types(request_dict)

        response = await self._api_client.async_request(
            "patch", path, request_dict, http_options
        )

        response_dict = {} if not response.body else json.loads(response.body)

        return_value = types.MultimodalDataset._from_response(
            response=response_dict, kwargs=parameter_model.model_dump()
        )

        self._api_client._verify_response(return_value)
        return return_value

    async def _wait_for_operation(
        self,
        operation: types.MultimodalDatasetOperation,
        timeout_seconds: int,
    ) -> types.MultimodalDataset:
        """Waits for a multimodal dataset operation to complete.

        Args:
          operation: The multimodal dataset operation to wait for.
          timeout_seconds: The maximum time in seconds to wait for the operation
          to complete.

        Returns:
          The name of the Multimodal Dataset resource from the operation result.

        Raises:
          TimeoutError: If the operation does not complete within the timeout.
          ValueError: If the operation fails.
        """
        multimodal_operation: Optional[types.MultimodalDatasetOperation] = None

        response_operation_name = operation.name
        dataset_id = response_operation_name.split("/datasets/")[1].split("/")[0]
        operation_id = response_operation_name.split("/")[-1]

        start_time = time.time()
        sleep_duration_seconds = 5
        wait_multiplier = 2
        max_wait_time_seconds = 60

        while (time.time() - start_time) < timeout_seconds:
            multimodal_operation = await self._get_multimodal_dataset_operation(
                dataset_id=dataset_id,
                operation_id=operation_id,
            )
            if multimodal_operation.done:
                break
            await asyncio.sleep(sleep_duration_seconds)
            sleep_duration_seconds = min(
                sleep_duration_seconds * wait_multiplier, max_wait_time_seconds
            )
        else:
            raise TimeoutError(
                "Create multimodal dataset operation did not complete within the"
                f" specified timeout of {timeout_seconds} seconds."
            )
        if (
            not multimodal_operation
            or multimodal_operation.response is None
            or multimodal_operation.response.name is None
        ):
            logger.error(
                f"Error creating multimodal dataset resource for the operation {operation.name}."
            )
            raise ValueError("Error creating multimodal dataset resource.")
        if (
            hasattr(multimodal_operation, "error")
            and multimodal_operation.error is not None
        ):
            raise ValueError(
                f"Error creating multimodal dataset resource: {multimodal_operation.error}"
            )
        return multimodal_operation.response

    async def create_from_bigquery(
        self,
        *,
        multimodal_dataset: types.MultimodalDatasetOrDict,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Creates a multimodal dataset from a BigQuery table.

        Args:
          multimodal_dataset:
            Required. A representation of a multimodal dataset.
          config:
            Optional. A configuration for creating the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing a multimodal dataset.
        """
        if isinstance(multimodal_dataset, dict):
            multimodal_dataset = types.MultimodalDataset(**multimodal_dataset)
        if not multimodal_dataset.metadata.input_config.bigquery_source.uri.startswith(
            "bq://"
        ):
            multimodal_dataset.metadata.input_config.bigquery_source.uri = (
                f"bq://{multimodal_dataset.metadata.input_config.bigquery_source.uri}"
            )
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        multimodal_dataset_operation = await self._create_multimodal_dataset(
            config=config,
            display_name=multimodal_dataset.display_name,
            metadata_schema_uri=_datasets_utils.METADATA_SCHEMA_URI,
            metadata=multimodal_dataset.metadata,
        )
        return await self._wait_for_operation(
            operation=multimodal_dataset_operation,
            timeout_seconds=config.timeout,
        )

    async def update_multimodal_dataset(
        self,
        *,
        multimodal_dataset: types.MultimodalDatasetOrDict,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Updates a multimodal dataset.

        Args:
          multimodal_dataset:
            Required. A representation of a multimodal dataset.
          config:
            Optional. A configuration for updating the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing the updated multimodal
          dataset.
        """
        if isinstance(multimodal_dataset, dict):
            multimodal_dataset = types.MultimodalDataset(**multimodal_dataset)
        if not multimodal_dataset.metadata.input_config.bigquery_source.uri.startswith(
            "bq://"
        ):
            multimodal_dataset.metadata.input_config.bigquery_source.uri = (
                f"bq://{multimodal_dataset.metadata.input_config.bigquery_source.uri}"
            )
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return await self._update_multimodal_dataset(
            config=config,
            name=multimodal_dataset.name,
            display_name=multimodal_dataset.display_name,
            description=multimodal_dataset.description,
            metadata=multimodal_dataset.metadata,
        )

    async def get_multimodal_dataset(
        self,
        *,
        name: str,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDataset:
        """Gets a multimodal dataset.

        Args:
          name:
            Required. name of a multimodal dataset.
          config:
            Optional. A configuration for getting the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDataset object representing the updated multimodal
          dataset.
        """
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return await self._get_multimodal_dataset(config=config, name=name)

    async def delete_multimodal_dataset(
        self,
        *,
        name: str,
        config: Optional[types.CreateMultimodalDatasetConfigOrDict] = None,
    ) -> types.MultimodalDatasetOperation:
        """Deletes a multimodal dataset.

        Args:
          name:
            Required. name of a multimodal dataset.
          config:
            Optional. A configuration for deleting the multimodal dataset. If not
            provided, the default configuration will be used.

        Returns:
          A types.MultimodalDatasetOperation object representing the delete
          multimodal dataset operation.
        """
        if isinstance(config, dict):
            config = types.CreateMultimodalDatasetConfig(**config)
        elif not config:
            config = types.CreateMultimodalDatasetConfig()

        return await self._delete_multimodal_dataset(config=config, name=name)
