# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import datetime
from typing import Any, Optional, Union
from google.genai import _common
from google.genai import types as genai_types
from pydantic import Field
from typing_extensions import TypedDict


class Importance(_common.CaseInSensitiveEnum):
    """Importance level of the rubric."""

    IMPORTANCE_UNSPECIFIED = "IMPORTANCE_UNSPECIFIED"
    """Importance is not specified."""
    HIGH = "HIGH"
    """High importance."""
    MEDIUM = "MEDIUM"
    """Medium importance."""
    LOW = "LOW"
    """Low importance."""


class Tools(_common.BaseModel):
    """This field is experimental and will be removed in future versions.

    Represents a list of tools for an agent.
    """

    tool: Optional[list[genai_types.Tool]] = Field(
        default=None,
        description="""List of tools: each tool can have multiple function declarations.""",
    )


class ToolsDict(TypedDict, total=False):
    """This field is experimental and will be removed in future versions.

    Represents a list of tools for an agent.
    """

    tool: Optional[list[genai_types.ToolDict]]
    """List of tools: each tool can have multiple function declarations."""


ToolsOrDict = Union[Tools, ToolsDict]


class InstanceDataContents(_common.BaseModel):
    """This field is experimental and will be removed in future versions.

    List of standard Content messages from Gemini API.
    """

    contents: Optional[list[genai_types.Content]] = Field(
        default=None, description="""Repeated contents."""
    )


class InstanceDataContentsDict(TypedDict, total=False):
    """This field is experimental and will be removed in future versions.

    List of standard Content messages from Gemini API.
    """

    contents: Optional[list[genai_types.ContentDict]]
    """Repeated contents."""


InstanceDataContentsOrDict = Union[InstanceDataContents, InstanceDataContentsDict]


class InstanceData(_common.BaseModel):
    """This field is experimental and will be removed in future versions.

    Instance data used to populate placeholders in a metric prompt template.
    """

    text: Optional[str] = Field(default=None, description="""Text data.""")
    contents: Optional[InstanceDataContents] = Field(
        default=None, description="""List of Gemini content data."""
    )


class InstanceDataDict(TypedDict, total=False):
    """This field is experimental and will be removed in future versions.

    Instance data used to populate placeholders in a metric prompt template.
    """

    text: Optional[str]
    """Text data."""

    contents: Optional[InstanceDataContentsDict]
    """List of Gemini content data."""


InstanceDataOrDict = Union[InstanceData, InstanceDataDict]


class AgentConfig(_common.BaseModel):
    """Represents configuration for an Agent."""

    agent_id: Optional[str] = Field(
        default=None,
        description="""Unique identifier of the agent.
      This ID is used to refer to this agent, e.g., in AgentEvent.author, or in
      the `sub_agents` field. It must be unique within the `agents` map.""",
    )
    agent_type: Optional[str] = Field(
        default=None,
        description="""The type or class of the agent (e.g., "LlmAgent", "RouterAgent",
      "ToolUseAgent"). Useful for the autorater to understand the expected
      behavior of the agent.""",
    )
    description: Optional[str] = Field(
        default=None,
        description="""A high-level description of the agent's role and responsibilities.
      Critical for evaluating if the agent is routing tasks correctly.""",
    )
    instruction: Optional[str] = Field(
        default=None,
        description="""The instructions for the LLM model, guiding the agent's behavior.
      Can be static or dynamic. Dynamic instructions can contain placeholders
      like {variable_name} that will be resolved at runtime using the
      `AgentEvent.state_delta` field.""",
    )
    tools: Optional[list[genai_types.Tool]] = Field(
        default=None, description="""The list of tools available to this agent."""
    )
    sub_agents: Optional[list[str]] = Field(
        default=None,
        description="""The list of valid agent IDs that this agent can delegate to.
      This defines the directed edges in the multi-agent system graph topology.""",
    )
    tools_text: Optional[str] = Field(
        default=None,
        description="""A JSON string containing a list of tools available to an agent.""",
    )
    legacy_tools: Optional[Tools] = Field(
        default=None, description="""List of tools."""
    )
    developer_instruction: Optional[InstanceData] = Field(
        default=None,
        description="""A field containing instructions from the developer for the agent.""",
    )


class AgentConfigDict(TypedDict, total=False):
    """Represents configuration for an Agent."""

    agent_id: Optional[str]
    """Unique identifier of the agent.
      This ID is used to refer to this agent, e.g., in AgentEvent.author, or in
      the `sub_agents` field. It must be unique within the `agents` map."""

    agent_type: Optional[str]
    """The type or class of the agent (e.g., "LlmAgent", "RouterAgent",
      "ToolUseAgent"). Useful for the autorater to understand the expected
      behavior of the agent."""

    description: Optional[str]
    """A high-level description of the agent's role and responsibilities.
      Critical for evaluating if the agent is routing tasks correctly."""

    instruction: Optional[str]
    """The instructions for the LLM model, guiding the agent's behavior.
      Can be static or dynamic. Dynamic instructions can contain placeholders
      like {variable_name} that will be resolved at runtime using the
      `AgentEvent.state_delta` field."""

    tools: Optional[list[genai_types.ToolDict]]
    """The list of tools available to this agent."""

    sub_agents: Optional[list[str]]
    """The list of valid agent IDs that this agent can delegate to.
      This defines the directed edges in the multi-agent system graph topology."""

    tools_text: Optional[str]
    """A JSON string containing a list of tools available to an agent."""

    legacy_tools: Optional[ToolsDict]
    """List of tools."""

    developer_instruction: Optional[InstanceDataDict]
    """A field containing instructions from the developer for the agent."""


AgentConfigOrDict = Union[AgentConfig, AgentConfigDict]


class AgentEvent(_common.BaseModel):
    """A single event in the execution trace."""

    author: Optional[str] = Field(
        default=None,
        description="""The ID of the agent or entity that generated this event.
      Use "user" to denote events generated by the end-user.""",
    )
    content: Optional[genai_types.Content] = Field(
        default=None, description="""The content of the event."""
    )
    event_time: Optional[datetime.datetime] = Field(
        default=None, description="""The timestamp when the event occurred."""
    )
    state_delta: Optional[dict[str, Any]] = Field(
        default=None,
        description="""The change in the session state caused by this event.
      This is a key-value map of fields that were modified or added by the event.""",
    )
    active_tools: Optional[list[genai_types.Tool]] = Field(
        default=None,
        description="""The list of tools that were active/available to the agent at the
      time of this event. This overrides the `AgentConfig.tools` if set.""",
    )


class AgentEventDict(TypedDict, total=False):
    """A single event in the execution trace."""

    author: Optional[str]
    """The ID of the agent or entity that generated this event.
      Use "user" to denote events generated by the end-user."""

    content: Optional[genai_types.ContentDict]
    """The content of the event."""

    event_time: Optional[datetime.datetime]
    """The timestamp when the event occurred."""

    state_delta: Optional[dict[str, Any]]
    """The change in the session state caused by this event.
      This is a key-value map of fields that were modified or added by the event."""

    active_tools: Optional[list[genai_types.ToolDict]]
    """The list of tools that were active/available to the agent at the
      time of this event. This overrides the `AgentConfig.tools` if set."""


AgentEventOrDict = Union[AgentEvent, AgentEventDict]


class ConversationTurn(_common.BaseModel):
    """Represents a single turn/invocation in the conversation."""

    turn_index: Optional[int] = Field(
        default=None,
        description="""The 0-based index of the turn in the conversation sequence.""",
    )
    turn_id: Optional[str] = Field(
        default=None, description="""A unique identifier for the turn."""
    )
    events: Optional[list[AgentEvent]] = Field(
        default=None,
        description="""The list of events that occurred during this turn.""",
    )


class ConversationTurnDict(TypedDict, total=False):
    """Represents a single turn/invocation in the conversation."""

    turn_index: Optional[int]
    """The 0-based index of the turn in the conversation sequence."""

    turn_id: Optional[str]
    """A unique identifier for the turn."""

    events: Optional[list[AgentEventDict]]
    """The list of events that occurred during this turn."""


ConversationTurnOrDict = Union[ConversationTurn, ConversationTurnDict]


class Events(_common.BaseModel):
    """This field is experimental and will be removed in future versions.

    Represents a list of events for an agent.
    """

    event: Optional[list[genai_types.Content]] = Field(
        default=None, description="""A list of events."""
    )


class EventsDict(TypedDict, total=False):
    """This field is experimental and will be removed in future versions.

    Represents a list of events for an agent.
    """

    event: Optional[list[genai_types.ContentDict]]
    """A list of events."""


EventsOrDict = Union[Events, EventsDict]


class AgentData(_common.BaseModel):
    """Represents data specific to multi-turn agent evaluations."""

    agents: Optional[dict[str, AgentConfig]] = Field(
        default=None,
        description="""A map containing the static configurations for each agent in the system.
      Key: agent_id (matches the `author` field in events).
      Value: The static configuration of the agent.""",
    )
    turns: Optional[list[ConversationTurn]] = Field(
        default=None,
        description="""A chronological list of conversation turns.
      Each turn represents a logical execution cycle (e.g., User Input -> Agent
      Response).""",
    )
    agent_config: Optional[AgentConfig] = Field(
        default=None, description="""Agent configuration."""
    )
    events_text: Optional[str] = Field(
        default=None, description="""A JSON string containing a sequence of events."""
    )
    events: Optional[Events] = Field(default=None, description="""A list of events.""")


class AgentDataDict(TypedDict, total=False):
    """Represents data specific to multi-turn agent evaluations."""

    agents: Optional[dict[str, AgentConfigDict]]
    """A map containing the static configurations for each agent in the system.
      Key: agent_id (matches the `author` field in events).
      Value: The static configuration of the agent."""

    turns: Optional[list[ConversationTurnDict]]
    """A chronological list of conversation turns.
      Each turn represents a logical execution cycle (e.g., User Input -> Agent
      Response)."""

    agent_config: Optional[AgentConfigDict]
    """Agent configuration."""

    events_text: Optional[str]
    """A JSON string containing a sequence of events."""

    events: Optional[EventsDict]
    """A list of events."""


AgentDataOrDict = Union[AgentData, AgentDataDict]


class AgentInfo(_common.BaseModel):
    """The agent info of an agent, used for agent eval."""

    agent_resource_name: Optional[str] = Field(
        default=None,
        description="""The agent engine used to run agent. Agent engine resource name in str type, with format
            `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine_id}`.""",
    )
    name: Optional[str] = Field(
        default=None, description="""Agent name, used as an identifier."""
    )
    instruction: Optional[str] = Field(
        default=None, description="""Agent developer instruction."""
    )
    description: Optional[str] = Field(
        default=None, description="""Agent description."""
    )
    tool_declarations: Optional[genai_types.ToolListUnion] = Field(
        default=None, description="""List of tools used by the Agent."""
    )

    @staticmethod
    def _get_tool_declarations_from_agent(agent: Any) -> genai_types.ToolListUnion:
        """Gets tool declarations from an agent.

        Args:
          agent: The agent to get the tool declarations from. Data type is google.adk.agents.LLMAgent type, use Any to avoid dependency on ADK.

        Returns:
          The tool declarations of the agent.
        """
        tool_declarations: genai_types.ToolListUnion = []
        for tool in agent.tools:
            tool_declarations.append(
                {
                    "function_declarations": [
                        genai_types.FunctionDeclaration.from_callable_with_api_option(
                            callable=tool
                        )
                    ]
                }
            )
        return tool_declarations

    @classmethod
    def load_from_agent(
        cls, agent: Any, agent_resource_name: Optional[str] = None
    ) -> "AgentInfo":
        """Loads agent info from an agent.

        Args:
          agent: The agent to get the agent info from, data type is google.adk.agents.LLMAgent type, use Any to avoid dependency on ADK.
          agent_resource_name: Optional. The agent engine resource name.

        Returns:
          The agent info of the agent.

        Example:
        ```
        from vertexai._genai import types

        # Assuming 'my_agent' is an instance of google.adk.agents.LLMAgent

        agent_info = types.evals.AgentInfo.load_from_agent(
            agent=my_agent,
            agent_resource_name="projects/123/locations/us-central1/reasoningEngines/456"
        )
        ```
        """
        return cls(  # pytype: disable=missing-parameter
            name=agent.name,
            agent_resource_name=agent_resource_name,
            instruction=agent.instruction,
            description=agent.description,
            tool_declarations=AgentInfo._get_tool_declarations_from_agent(agent),
        )


class AgentInfoDict(TypedDict, total=False):
    """The agent info of an agent, used for agent eval."""

    agent_resource_name: Optional[str]
    """The agent engine used to run agent. Agent engine resource name in str type, with format
            `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine_id}`."""

    name: Optional[str]
    """Agent name, used as an identifier."""

    instruction: Optional[str]
    """Agent developer instruction."""

    description: Optional[str]
    """Agent description."""

    tool_declarations: Optional[genai_types.ToolListUnionDict]
    """List of tools used by the Agent."""


AgentInfoOrDict = Union[AgentInfo, AgentInfoDict]


class RubricContentProperty(_common.BaseModel):
    """Defines criteria based on a specific property."""

    description: Optional[str] = Field(
        default=None,
        description="""Description of the property being evaluated.
      Example: "The model's response is grammatically correct." """,
    )


class RubricContentPropertyDict(TypedDict, total=False):
    """Defines criteria based on a specific property."""

    description: Optional[str]
    """Description of the property being evaluated.
      Example: "The model's response is grammatically correct." """


RubricContentPropertyOrDict = Union[RubricContentProperty, RubricContentPropertyDict]


class RubricContent(_common.BaseModel):
    """Content of the rubric, defining the testable criteria."""

    property: Optional[RubricContentProperty] = Field(
        default=None,
        description="""Evaluation criteria based on a specific property.""",
    )


class RubricContentDict(TypedDict, total=False):
    """Content of the rubric, defining the testable criteria."""

    property: Optional[RubricContentPropertyDict]
    """Evaluation criteria based on a specific property."""


RubricContentOrDict = Union[RubricContent, RubricContentDict]


class Rubric(_common.BaseModel):
    """Message representing a single testable criterion for evaluation.

    One input prompt could have multiple rubrics.
    """

    rubric_id: Optional[str] = Field(
        default=None,
        description="""Required. Unique identifier for the rubric.
      This ID is used to refer to this rubric, e.g., in RubricVerdict.""",
    )
    content: Optional[RubricContent] = Field(
        default=None,
        description="""Required. The actual testable criteria for the rubric.""",
    )
    type: Optional[str] = Field(
        default=None,
        description="""Optional. A type designator for the rubric, which can inform how it's
      evaluated or interpreted by systems or users.
      It's recommended to use consistent, well-defined, upper snake_case strings.
      Examples: "SUMMARIZATION_QUALITY", "SAFETY_HARMFUL_CONTENT",
      "INSTRUCTION_ADHERENCE".""",
    )
    importance: Optional[Importance] = Field(
        default=None,
        description="""Optional. The relative importance of this rubric.""",
    )


class RubricDict(TypedDict, total=False):
    """Message representing a single testable criterion for evaluation.

    One input prompt could have multiple rubrics.
    """

    rubric_id: Optional[str]
    """Required. Unique identifier for the rubric.
      This ID is used to refer to this rubric, e.g., in RubricVerdict."""

    content: Optional[RubricContentDict]
    """Required. The actual testable criteria for the rubric."""

    type: Optional[str]
    """Optional. A type designator for the rubric, which can inform how it's
      evaluated or interpreted by systems or users.
      It's recommended to use consistent, well-defined, upper snake_case strings.
      Examples: "SUMMARIZATION_QUALITY", "SAFETY_HARMFUL_CONTENT",
      "INSTRUCTION_ADHERENCE"."""

    importance: Optional[Importance]
    """Optional. The relative importance of this rubric."""


RubricOrDict = Union[Rubric, RubricDict]


class RubricVerdict(_common.BaseModel):
    """Represents the verdict of an evaluation against a single rubric."""

    evaluated_rubric: Optional[Rubric] = Field(
        default=None,
        description="""Required. The full rubric definition that was evaluated.
      Storing this ensures the verdict is self-contained and understandable,
      especially if the original rubric definition changes or was dynamically
      generated.""",
    )
    verdict: Optional[bool] = Field(
        default=None,
        description="""Required. Outcome of the evaluation against the rubric, represented as a
      boolean. `true` indicates a "Pass", `false` indicates a "Fail".""",
    )
    reasoning: Optional[str] = Field(
        default=None,
        description="""Optional. Human-readable reasoning or explanation for the verdict.
      This can include specific examples or details from the evaluated content
      that justify the given verdict.""",
    )


class RubricVerdictDict(TypedDict, total=False):
    """Represents the verdict of an evaluation against a single rubric."""

    evaluated_rubric: Optional[RubricDict]
    """Required. The full rubric definition that was evaluated.
      Storing this ensures the verdict is self-contained and understandable,
      especially if the original rubric definition changes or was dynamically
      generated."""

    verdict: Optional[bool]
    """Required. Outcome of the evaluation against the rubric, represented as a
      boolean. `true` indicates a "Pass", `false` indicates a "Fail"."""

    reasoning: Optional[str]
    """Optional. Human-readable reasoning or explanation for the verdict.
      This can include specific examples or details from the evaluated content
      that justify the given verdict."""


RubricVerdictOrDict = Union[RubricVerdict, RubricVerdictDict]


class CandidateResult(_common.BaseModel):
    """Result for a single candidate."""

    candidate: Optional[str] = Field(
        default=None,
        description="""The candidate that is being evaluated. The value is the same as the candidate name in the EvaluationRequest.""",
    )
    metric: Optional[str] = Field(
        default=None, description="""The metric that was evaluated."""
    )
    score: Optional[float] = Field(
        default=None, description="""The score of the metric."""
    )
    explanation: Optional[str] = Field(
        default=None, description="""The explanation for the metric."""
    )
    rubric_verdicts: Optional[list[RubricVerdict]] = Field(
        default=None, description="""The rubric verdicts for the metric."""
    )
    additional_results: Optional[dict[str, Any]] = Field(
        default=None, description="""Additional results for the metric."""
    )


class CandidateResultDict(TypedDict, total=False):
    """Result for a single candidate."""

    candidate: Optional[str]
    """The candidate that is being evaluated. The value is the same as the candidate name in the EvaluationRequest."""

    metric: Optional[str]
    """The metric that was evaluated."""

    score: Optional[float]
    """The score of the metric."""

    explanation: Optional[str]
    """The explanation for the metric."""

    rubric_verdicts: Optional[list[RubricVerdictDict]]
    """The rubric verdicts for the metric."""

    additional_results: Optional[dict[str, Any]]
    """Additional results for the metric."""


CandidateResultOrDict = Union[CandidateResult, CandidateResultDict]


class Event(_common.BaseModel):
    """Represents an event in a conversation between agents and users.

    It is used to store the content of the conversation, as well as the actions
    taken by the agents like function calls, function responses, intermediate NL
    responses etc.
    """

    event_id: Optional[str] = Field(
        default=None, description="""Unique identifier for the agent event."""
    )
    content: Optional[genai_types.Content] = Field(
        default=None, description="""Content of the event."""
    )
    creation_timestamp: Optional[datetime.datetime] = Field(
        default=None, description="""The creation timestamp of the event."""
    )
    author: Optional[str] = Field(
        default=None, description="""Name of the entity that produced the event."""
    )


class EventDict(TypedDict, total=False):
    """Represents an event in a conversation between agents and users.

    It is used to store the content of the conversation, as well as the actions
    taken by the agents like function calls, function responses, intermediate NL
    responses etc.
    """

    event_id: Optional[str]
    """Unique identifier for the agent event."""

    content: Optional[genai_types.ContentDict]
    """Content of the event."""

    creation_timestamp: Optional[datetime.datetime]
    """The creation timestamp of the event."""

    author: Optional[str]
    """Name of the entity that produced the event."""


EventOrDict = Union[Event, EventDict]


class Message(_common.BaseModel):
    """Represents a single message turn in a conversation."""

    turn_id: Optional[str] = Field(
        default=None, description="""Unique identifier for the message turn."""
    )
    content: Optional[genai_types.Content] = Field(
        default=None, description="""Content of the message, including function call."""
    )
    creation_timestamp: Optional[datetime.datetime] = Field(
        default=None,
        description="""Timestamp indicating when the message was created.""",
    )
    author: Optional[str] = Field(
        default=None, description="""Name of the entity that produced the message."""
    )


class MessageDict(TypedDict, total=False):
    """Represents a single message turn in a conversation."""

    turn_id: Optional[str]
    """Unique identifier for the message turn."""

    content: Optional[genai_types.ContentDict]
    """Content of the message, including function call."""

    creation_timestamp: Optional[datetime.datetime]
    """Timestamp indicating when the message was created."""

    author: Optional[str]
    """Name of the entity that produced the message."""


MessageOrDict = Union[Message, MessageDict]


class SessionInput(_common.BaseModel):
    """This field is experimental and may change in future versions.

    Input to initialize a session and run an agent, used for agent evaluation.
    """

    user_id: Optional[str] = Field(default=None, description="""The user id.""")
    state: Optional[dict[str, str]] = Field(
        default=None, description="""The state of the session."""
    )
    app_name: Optional[str] = Field(
        default=None,
        description="""The name of the app, used for local ADK agent run Runner and Session.""",
    )


class SessionInputDict(TypedDict, total=False):
    """This field is experimental and may change in future versions.

    Input to initialize a session and run an agent, used for agent evaluation.
    """

    user_id: Optional[str]
    """The user id."""

    state: Optional[dict[str, str]]
    """The state of the session."""

    app_name: Optional[str]
    """The name of the app, used for local ADK agent run Runner and Session."""


SessionInputOrDict = Union[SessionInput, SessionInputDict]
